package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    // Apparently there is a cup bug that causes expected_token_ids() to return incorrect results on first call
    // This is why this call is inserted.
    this.expected_token_ids();
    
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right),
            this.symbl_name_from_id(currentToken.sym),
            this.expected_token_ids().stream().map(this::symbl_name_from_id).toList());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

/* Non-terminals */
non terminal Program program;
non terminal GlobalDefinition GlobalDeclaration;
non terminal TypeDefinition TypeDeclaration;
non terminal TypeExpression TypeExpression;
non terminal ProcedureDefinition ProcedureDeclaration;
non terminal ParameterDefinition ParameterDeclaration;
non terminal VariableDefinition VariableDeclaration;
non terminal AssignStatement AssignStmt;
non terminal CallStatement CallStmt;
non terminal CompoundStatement CompoundStmt;
non terminal EmptyStatement EmptyStmt;
non terminal IfStatement IfStmt;
non terminal WhileStatement WhileStmt;
non terminal Statement Statement;
non terminal Expression Expr;
non terminal Expression Expr1;
non terminal Expression Expr2;
non terminal Expression Expr3;
non terminal Expression Expr4;
non terminal Variable VarName;

non terminal List<GlobalDefinition> GlobalDecList;
non terminal List<ParameterDefinition> ParameterList;
non terminal List<ParameterDefinition> NotEmptyParameterList;
non terminal List<VariableDefinition> VariableList;
non terminal List<Statement> StatementList;
non terminal List<Expression> ArgumentExprList;
non terminal List<Expression> NotEmptyArgument;


start with program;

//TODO (assignment 2 and 3): Just a dummy, needs to be replaced by the actual spl grammar.

//SPL Program contains of many global declarations
program ::= GlobalDecList:list {:
                RESULT = new Program(new Position(listleft, listright), list);
            :}
;

//GL : G  GL | empty;
GlobalDecList ::= GlobalDeclaration:head GlobalDecList:tail {:
                    RESULT = cons(head, tail);
                :}
                | /*empty*/ {:
                    RESULT = nil();
                :}
                ;

//A Global declaration has 2 type of declaration 1.) Type Declaration 2.) Procedure Declaration
GlobalDeclaration ::= TypeDeclaration:name {:
                        RESULT = name;
                    :}
                    | ProcedureDeclaration:name {:
                        RESULT = name;
                    :}
                    ;

TypeDeclaration ::= TYPE:pos IDENT:name EQ TypeExpression:typeExpression SEMIC {:
                        RESULT = new TypeDefinition(new Position(posleft, posright), name, typeExpression);
                    :}
                    ;

TypeExpression ::= IDENT //Named Typed Expression
                 | ARRAY LBRACK INTLIT RBRACK OF TypeExpression; //Array type Expression

//proc proc_name(parameters){ variables_and_statements }
ProcedureDeclaration ::= PROC IDENT LPAREN ParameterList RPAREN LCURL VariableList StatementList RCURL;

ParameterList ::= NotEmptyParameterList
                | /*EmptyDeclaration*/;

//NotEmptyParameterList is called if the parameter is not empty
NotEmptyParameterList ::= ParameterDeclaration
                        | ParameterDeclaration COMMA NotEmptyParameterList;

ParameterDeclaration ::= IDENT COLON TypeExpression | REF IDENT COLON TypeExpression;

VariableList ::= VariableDeclaration VariableList
                | /*EmtpyVariableList*/;

VariableDeclaration ::= VAR IDENT COLON TypeExpression SEMIC;

StatementList ::= Statement StatementList | /*EmptyStatement*/;

//Statements have various type such as:
Statement ::= AssignStmt
            | CallStmt
            | CompoundStmt
            | WhileStmt
            | IfStmt
            | /*emptyStatement*/ SEMIC;

AssignStmt ::= VarName ASGN Expr1 SEMIC;

CallStmt ::= IDENT LPAREN ArgumentExprList RPAREN SEMIC;

CompoundStmt ::= LCURL StatementList RCURL;

WhileStmt ::= WHILE LPAREN Expr RPAREN Statement;

IfStmt ::= IF LPAREN Expr RPAREN Statement
         | IF LPAREN Expr RPAREN Statement ELSE Statement; // Normaly followed with compound statement

//ArgumentList for Call Statement
ArgumentExprList ::= NotEmptyArgument
                    | /* EmptyArgument */ ;

NotEmptyArgument ::= Expr1 COMMA NotEmptyArgument
                    | Expr1 ;

VarName ::= IDENT
            | VarName LBRACK Expr1 RBRACK;

Expr ::= Expr1
        | Expr1 LT Expr1
        | Expr1 LE Expr1
        | Expr1 GT Expr1
        | Expr1 GE Expr1
        | Expr1 EQ Expr1
        | Expr1 NE Expr1 ;

Expr1 ::= Expr1 PLUS Expr2
        | Expr1 MINUS Expr2
        | Expr2 ;

Expr2 ::= Expr2 STAR Expr3
        | Expr2 SLASH Expr3
        | Expr3 ;

Expr3 ::= LPAREN Expr1 RPAREN
        | INTLIT
        | VarName
        | MINUS Expr3 ;



